(require 'uiop)

(defun read-key-lock-file (filename)
  (let ((rows (uiop:read-file-lines filename))
        (keys)
        (locks))
    (dotimes (n (ceiling (length rows) 8))
      (flet ((numeric-row (i)
               (mapcar (lambda (c) (if (eq c #\#) 1 0)) (coerce (nth i rows) 'list))))
        (let* ((i0 (* n 8))
               (i6 (+ i0 6))
               (is-lock (string= (nth i0 rows) "#####"))
               (is-key (string= (nth i6 rows) "#####"))
               (cols (reduce (lambda (a b)
                               (mapcar #'+ a b))
                             (mapcar #'numeric-row
                                     (loop for i from (1+ i0) to (1- i6) collect i)))))
          (assert (not (eq is-key is-lock)))
          (if is-key (push cols keys) (push cols locks)))))
    (values keys locks)))

(defun fits-lock (lock)
  (lambda (key)
    (let ((fits (every (lambda (kx lx) (<= (+ kx lx) 5)) key lock)))
      ;;(format t "Lock ~a and key ~a? ~a~%" lock key (if fits "YES" "no"))
      fits)))

(defun fitting-lock-key-pairs (filename)
  (multiple-value-bind (keys locks) (read-key-lock-file filename)
    (mapcan (lambda (lock)
              (let ((fits (fits-lock lock)))
                (mapcar (lambda (key) (list lock key))
                        (remove-if-not fits keys))))
            locks)))

;;(print (fitting-lock-key-pairs "test.txt"))
(assert (= (length (fitting-lock-key-pairs "test.txt")) 3))
(print (length (fitting-lock-key-pairs "input.txt")))
