(require 'uiop)
(load "hash-table")

(defun transform-stone (x)
  (let ((xs (format nil "~a" x)))
    (cond ((zerop x) (list 1))
          ((evenp (length xs))
           (let ((half (/ (length xs) 2)))
             (mapcar #'parse-integer (list (subseq xs 0 half) (subseq xs half)))))
          (t (list (* 2024 x))))))

(compile 'transform-stone)

(defun stones-after (blinks stone-list)
  (if (zerop blinks)
      stone-list
      (stones-after (1- blinks) (mapcan #'transform-stone stone-list))))

(compile 'stones-after)

(defun num-stones-after (blinks stone-list)
  (let ((ht (make-hash-table)))
    (mapc (lambda (stone)
            (setf (gethash stone ht) 1))
          stone-list)
    (dotimes (i blinks)
      (let ((prev-stones (copy-list (hash-keys-and-values ht))))
        (setf ht (make-hash-table))
        (mapc (lambda (stone-and-count)
                (let ((new-stones (transform-stone (car stone-and-count)))
                      (count (cdr stone-and-count)))
                  (mapc (lambda (stone)
                          (let ((old-count (gethash stone ht 0)))
                            (setf (gethash stone ht) (+ old-count count))))
                        new-stones)))
              prev-stones)))
    (reduce #'+ (hash-values ht))))

(assert (= (num-stones-after 6 '(125 17)) 22))
(assert (= (num-stones-after 25 '(125 17)) 55312))
(assert (= (print (num-stones-after 25 '(77 515 6779622 6 91370 959685 0 9861))) 187738))
(print (num-stones-after 75 '(77 515 6779622 6 91370 959685 0 9861)))
