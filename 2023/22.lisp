(load "22-bricks")

(defun x (corner) (car corner))
(defun y (corner) (cadr corner))
(defun z (corner) (caddr corner))

(defun at-ground-p (brick)
  (= 1 (z (car brick))))

(defun brick-dec-z (brick)
  (let ((c0 (car brick))
	(c1 (cadr brick)))
    (list (list (x c0) (y c0) (1- (z c0)))
	  (list (x c1) (y c1) (1- (z c1)))
	  (caddr brick))))

(defun supported-by (top bottom)
  (when (= (1+ (z (cadr bottom))) (z (car top)))
    (flet ((overlaps (f)
	     (let ((b0 (funcall f (car bottom)))
		   (b1 (funcall f (cadr bottom)))
		   (t0 (funcall f (car top)))
		   (t1 (funcall f (cadr top))))
	       (or (<= b0 t0 b1) (<= b0 t1 b1)
		   (<= t0 b0 t1) (<= t0 b1 t1)))))
      (and (overlaps #'x) (overlaps #'y)))))

(assert (supported-by '((0 0 2) (2 0 2) 'B)
		      '((1 0 1) (1 2 1) 'A)))

(defun sort-by-top-z (bricks)
  (sort (copy-seq bricks) (lambda (a b) (< (z (cadr a)) (z (cadr b))))))

(defun fall-to-ground (bricks)
  (let ((settled))
    (labels ((settle (cur)
	       (if (or (at-ground-p cur)
		       (some (lambda (x) (supported-by cur x)) settled))
		   (push cur settled)
		   (settle (brick-dec-z cur)))))
      (mapc #'settle (sort-by-top-z bricks)))
    settled))

(defun supporters (subj bricks)
  (remove-if-not (lambda (x)
		   (and (not (equal x subj))
			(supported-by subj x)))
		 bricks))

(defun safe-to-dis (subj bricks)
  (notany (lambda (x)
	    (equal (list subj) (supporters x bricks)))
	  bricks))

(defun num-safe-to-dis (bricks)
  (count t (mapcar (lambda (x)
		     (safe-to-dis x bricks))
		   bricks)))

(let* ((br (reverse (fall-to-ground (car *bricks*))))
       (a (nth 0 br))
       (b (nth 1 br))
       (c (nth 2 br))
       (d (nth 3 br))
       (e (nth 4 br))
       (f (nth 5 br))
       (g (nth 6 br)))
  (assert (equal (list a) (supporters b br)))
  (assert (equal (list a) (supporters c br)))
  (assert (equal (list b c) (supporters d br)))
  (assert (equal (list b c) (supporters e br)))
  (assert (equal (list d e) (supporters f br)))
  (assert (equal (list f) (supporters g br)))
  (assert (not (safe-to-dis a br)))
  (assert (safe-to-dis b br))
  (assert (safe-to-dis c br))
  (assert (safe-to-dis d br))
  (assert (safe-to-dis e br))
  (assert (not (safe-to-dis f br)))
  (assert (safe-to-dis g br))
  (assert (= (num-safe-to-dis br) 5)))

(defun main ()
  (num-safe-to-dis (fall-to-ground (cadr *bricks*))))
